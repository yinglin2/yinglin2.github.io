(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{294:function(t,a,v){t.exports=v.p+"assets/img/image-20240126191717440.e98ab496.png"},295:function(t,a,v){t.exports=v.p+"assets/img/image-20240126193618147.f002e4ae.png"},296:function(t,a,v){t.exports=v.p+"assets/img/image-20240127130500376.9ef3e954.png"},297:function(t,a,v){t.exports=v.p+"assets/img/image-20240127131945432.a42729ec.png"},309:function(t,a,v){"use strict";v.r(a);var s=v(14),_=Object(s.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"什么是rpc"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是rpc"}},[t._v("#")]),t._v(" 什么是RPC?")]),t._v(" "),a("p",[t._v("RPC的全称是Remote Procedure Call, 即远程过程调用。 RPC帮助我们屏蔽了网络编程细节，实现调用远程方法就跟调用本地方法一样的体验。")]),t._v(" "),a("p",[t._v("RPC的主要作用体现在以下两方面：")]),t._v(" "),a("ol",[a("li",[t._v("屏蔽远程调用跟本地调用的区别，让我们感觉就是调用项目内的方法")]),t._v(" "),a("li",[t._v("隐藏底层网络通信的复杂性，让我们更专注业务逻辑")])]),t._v(" "),a("h1",{attrs:{id:"rpc通信流程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#rpc通信流程"}},[t._v("#")]),t._v(" RPC通信流程")]),t._v(" "),a("p",[t._v("在RPC框架中，服务调用的发起者叫做调用方，被调用的一方叫做服务的提供方。它们之间需要通过网络来传输数据。为了确保数据传输的可靠性，默认情况下, RPC是采用TCP来传输的。")]),t._v(" "),a("p",[a("img",{attrs:{src:v(294),alt:"image-20240126191717440"}})]),t._v(" "),a("ol",[a("li",[a("p",[t._v("发送请求和数据：由于网络传输过程中必须是二进制数据。在面向对象语言中，比如java，数据参数一般都是保存在对象当中的。所以我们需要把对象转变成可传输的二进制，并且要求这个转换算法是可逆的，这个过程叫做“序列化”。")])]),t._v(" "),a("li",[a("p",[t._v("接收请求和数据：调用方把数据序列化成二进制数据后，经过TCP将数据发送给服务提供方。那么这里有一个问题就是服务提供方是如何知道一个请求的数据到哪里结束，是一个什么类型的请求呢？")]),t._v(" "),a("p",[t._v("我们是通过“协议”规定了数据包的类型和长度。大多数的协议会分成两个部分，分别是数据头和消息体。数据头一般用于身份识别，包括协议标识、数据大小、请求类型、序列化类型等信息；消息头主要是请求的业务参数信息和扩展属性等。")]),t._v(" "),a("p",[t._v("据协议格式，服务提供方就可以正确地从二进制数据中分割出不同的请求来，同时根据请求类型和序列化类型，把二进制的消息体逆向还原成请求对象。这个过程叫作“反序列化”。")])]),t._v(" "),a("li",[a("p",[t._v("回复请求：服务提供方再根据反序列化出来的请求对象找到对应的实现类，完成真正的方法调用，然后 把执行结果序列化后，回写到对应的 TCP 通道里面。调用方获取到应答的数据包后，再反 序列化成应答对象，这样调用方就完成了一次 RPC 调用。")])])]),t._v(" "),a("p",[a("img",{attrs:{src:v(295),alt:"image-20240126193618147"}})]),t._v(" "),a("h1",{attrs:{id:"rpc协议"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#rpc协议"}},[t._v("#")]),t._v(" RPC协议")]),t._v(" "),a("p",[a("strong",[t._v("为什么需要协议？")])]),t._v(" "),a("p",[t._v("因为我们需要把对象数据转变成二进制数据才能够在网络中传输，传输过程中，RPC可能会不会把数据放在一个数据包下一起发送，可能会拆分成好几个数据包发送，所以我们需要一个协议去规定，让接收方可以正确的分清楚数据的边界，正确解析数据。")]),t._v(" "),a("p",[a("strong",[t._v("怎么设计一个RPC协议呢？")])]),t._v(" "),a("p",[t._v("我们最熟悉的协议应该就是HTTP协议, RPC和HTTP协议都是应用层的协议。为什么我们不能直接使用HTTP协议呢？")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("这是因为RPC主要是用来负责应用间的通信，所以会对性能要求比较高。但是HTTP协议的数据包大小相对请求数据本身要大的很多，又需要加入很多无用的内容，比如换行符号、回车符等。")])]),t._v(" "),a("li",[a("p",[t._v("HTTP协议属于无状态协议，客户端无法对请求和响应进行关联，每次请求都需要重新建立连接，响应完成后再关闭连接。因此，对于要求高性能的RPC来说，HTTP协议基本是很难满足需求，所以 RPC 会选择设计更紧凑的私有协议")])])]),t._v(" "),a("p",[t._v("但是协议之间都有互通的地方，通过观察HTTP协议，我们可以从中学到什么？")]),t._v(" "),a("p",[a("img",{attrs:{src:v(296),alt:"image-20240127130500376"}})]),t._v(" "),a("ol",[a("li",[t._v("HTTP分成请求头和请求体两部分：RPC协议同样可以将数据包分成协议头和协议体。在协议头里面会存放参数信息。协议体就是二进制数据。")]),t._v(" "),a("li",[t._v("HTTP请求头包含数据类型，压缩编码，语言等信息：设计RPC同样需要一个固定位置去存放一些请求的参数信息，比如消息长度，消息类型，序列化方式等信息，以便接收方可以正确的解析数据。")]),t._v(" "),a("li",[t._v("我们还需要协议是可扩展的：往后我们可能需要往协议头增加参数，如果接收方的没有更新RPC的版本，那么就可能错误解析了请求协议。我们可以增加一个固定位置，去读取长度。并且增加一个可扩展字段，如果有增加内容，可以写入在这个位置。")])]),t._v(" "),a("p",[a("img",{attrs:{src:v(297),alt:"image-20240127131945432"}})])])}),[],!1,null,null,null);a.default=_.exports}}]);